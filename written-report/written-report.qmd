---
title: "Draft"
subtitle: "STA 210 - Project"
author: "Ginger and Stats - Aimi Wen, Rakshita Ramakrishna, Nathan Nguyen"
format: pdf
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE,
                      fig.width = 10, fig.asp = 0.618, out.width = "90%",
  fig.retina = 3, dpi = 300, fig.align = "center")
```

```{r}
#| label: load-pkg-data
#| warning: false
library(tidyverse)
library(tidymodels)
library(tidytext)
library(patchwork)
library(stringr)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(countrycode)
library(kableExtra)
chocolate <- read_csv("../data/chocolate.csv")

world <- ne_countries(scale = "medium", returnclass = "sf")

ggplot2::theme_set(ggplot2::theme_minimal(base_size = 20))
```

# Introduction and data

## Broader Context + Research Question

Chocolate is one of the most popular sweets in the world-- according to the World Cocoa Foundation, more than 3 million tons of cocoa beans a year are consumed. Dark chocolate, which this dataset focuses on, has been linked to increase heart health, balance the immune system, combat diabetes, improve brain function, boost athletic performance, and reduce stress (1). While dark chocolate can be helpful to human health, arguably, its popularity is due to its taste and its ability to make us "feel good."  Studies have found that the ability to make us "feel good" is due to the psychoactive chemicals it contains (2). For serious chocolate lovers, chocolate's particular chemical signature can be needed by chocolate lovers' metabolic systems, thus making the treat particularly delicious to them (3).  But other than the chemical compounds in chocolate, how does taste impact chocolate's likeability? What other factors can impact chocolate's likeability? Our dataset contains different dark chocolate bars. One of the columns is chocolate ratings, which are made by members of the Manhattan Chocolate Society. Using the chocolate rating as an indication of the chocolate's likeability, our general research question, therefore, is what can predict chocolate ratings? 

Based on our research question, we have the following hypotheses:

1.  A lower cocoa percentage is linked to a higher rating. 

2.  Chocolate companies that are located in the USA or a European country will have higher ratings. 

3.  Cocoa percentage and ingredients are the strongest predictors. 

4.  Country of bean origin will not be a strong predictor. 

References:

1.  <https://www.hopkinsmedicine.org/health/wellness-and-prevention/the-benefits-of-having-a-healthy-relationship-with-chocolate>

2.  https://www.bbc.com/news/health-39067088

3.  <https://www.acs.org/content/acs/en/pressroom/newsreleases/2007/october/news-release-study-finds-that-people-are-programmed-to-love-chocolate.html>

## Data description

The data is collected by members of the Manhattan Chocolate Society reviewing chocolate bars using the rating system found at <http://flavorsofcacao.com/review_guide.html> and adding other characteristics about the bar itself. It is being continuously collected and added to the dataset after reviewing chocolate bars - this can be seen as the first review years for chocolate bars began in 2006 and have continued until 2021. It contains 2530 observations, each represents a review of general characteristics for different chocolate bars. A single observation in this dataset represents a single chocolate bars

The general characteristics that will be our main interest are described as follows:

-   Company (Manufacturer) lists who made the chocolate bar reviewed; the dataset also lists where this company is located under Company Location.

-   The dataset characterizes the Country of Bean Origin, Specific Bean Origin or name of bar, Percentage of Cocoa within the bar for each chocolate bar.

-   The data also shows which ingredients are used using letters, where B = Beans, S = Sugar, S\* = Sweeteners other than white can or beet sugar, C = Cocoa Butter, V = Vanilla, L = Lecithin, Sa = Salt.

-   Finally, the data shows the rating (which ranges from 1-5, incrementing by 0.25) given under their rating system, which is linked above, as well as the date it was reviewed on.

The data dictionary can be found [here](https://github.com/sta210-s22/project-ginger_and_stats/tree/main/data).

## Methodology

### Exploratory Data Analysis (EDA)

Before we began modeling, we first performed some Exploratory Data Analysis to decide how we were going to use the variables in our modeling.

### Shape of Ratings

```{r}
#| label: fig-rating
#| fig-cap: "Ratings"
ggplot(chocolate, aes(rating)) +
  geom_histogram(binwidth = 0.25, color = "white")+
  labs(
    title = "Distribution of rating",
    x = "Rating"
  )
```

From @fig-rating, we can see that the distribution of the rating is unimodal, centered around the value of 3 or 3.25. It is also left-skewed, with some possible outliers of value 1 or 1.5.

```{r}
chocolate %>%
  summarise(
    mean = mean(rating),
    median = median(rating),
    sd = sd(rating)
  ) %>%
  kable(digits = 3)
```

### Cocoa Percent

```{r}
#| label: fig-percent-rating
#| fig-cap: "Cocoa Percent and Ratings"

chocolate$cocoa_percent <- as.numeric(gsub('[,%]', '', chocolate$cocoa_percent))

chocolate$rating <- as.character(chocolate$rating) 
ggplot(data= chocolate, aes(x= cocoa_percent, y= rating)) + geom_boxplot() +
  labs(title = "Distribution of Cocoa Percent versus Chocolate Rating",
       y = "Rating",
       x = "Chocolate Rating")

chocolate$rating <- as.numeric(chocolate$rating) 
```

From @fig-percent-rating, we can see a general rough trend that as the median cocoa percent is lower, the rating of the chocolate bar is higher. Furthermore, there appear to be a lot of outliers in the middle ratings (2.25 - 3.75), which might be due to the fact that that is the rating for the bulk of the chocolates tested.

### Ingredients

```{r}
#| label: ingredients-seperate

chocolate <- chocolate %>%
  mutate(lecithin = case_when(
    grepl("L", ingredients) ~ 1,
    T ~ 0
  ),
  vanilla = case_when(
    grepl("V", ingredients) ~ 1,
    T ~ 0
  ),
  cocoa = case_when(
    grepl("C", ingredients) ~ 1,
    T ~ 0
  ),
  salt = case_when(
    grepl("Sa", ingredients) ~ 1,
    T ~ 0
  ),
  
  lecithin = as.factor(lecithin),
  vanilla = as.factor(vanilla),
  cocoa = as.factor(cocoa),
  salt = as.factor(salt)
  )
```

```{r}
#| label: fig-ingre-vis
#| fig-cap: "Rating and Ingredients"

pL <- ggplot(chocolate, aes(lecithin, fill = as.factor(rating))) +
  geom_bar(position = "fill") + 
  labs(title = "Distribution of Lecithin",
       y = "Rating",
       x = "Presence of Lecithin") +
  theme(legend.position = "none")
pV <- ggplot(chocolate, aes(vanilla, fill = as.factor(rating))) +
    labs(title = "Distribution of Vanilla",
       y = "Rating",
       x = "Presence of Vanilla") + 
  geom_bar(position = "fill") +
  theme(legend.position = "none")
pC <- ggplot(chocolate, aes(cocoa, fill = as.factor(rating))) +
  geom_bar(position = "fill") +
    labs(title = "Distribution of Cocoa Butter",
       y = "Rating",
       x = "Presence of Cocoa Butter") + 
  theme(legend.position = "none")
pSa <- ggplot(chocolate, aes(salt, fill = as.factor(rating))) +
    labs(title = "Distribution of Salt",
       y = "Rating",
       x = "Presence of Salt",
       fill = "Rating") + 
  geom_bar(position = "fill")

(pL + pV)/(pC + pSa)

```

From @fig-ingre-vis, we can see that the presence of salt and vanilla seem to affect the rating the most out of all the predicters. The presence of salt and vanilla results in more lower ratings, while the amount of high and low ratings remains roughly the same with/without the presence of cocoa butter and lecithin.

```{r}
#| label: fig-num-ingres
#| fig-cap: "Number of Ingredients and Ratings"

chocolate <- chocolate %>%
  mutate(
    num_ingres = if_else(is.na(ingredients), "0", str_sub(ingredients, 1, 1)),
    num_ingres = as.numeric(num_ingres)
  )

ggplot(chocolate, aes(num_ingres))+
  geom_histogram(binwidth = 1)+
  labs(
    title = "Distribution of number of ingredients",
    x = "Number of ingredients", 
    y = "Count"
  )
```

In @fig-num-ingres, we regard the NA value of ingredients as 0, which means we should understand this as nonrecorded value instead of no ingredients are presented in the chocolate. This visualization showcases a right skewed distribution for the number of ingredients. The median is somewhere around 3 ingredients, and there appears to be an outlier centered around 0. This could be as many chocolate bars use at least one of the common ingredients, and it is quite rare for a chocolate bar not to have any of those ingredients.

### Most Memorable Characteristic

```{r}
#| label: fig-mem-char
#| fig-cap: "Memorable Characteristics"

tidy_chocolate<- chocolate %>% 
  unnest_tokens(word, most_memorable_characteristics)

tidy_chocolate %>% 
  group_by(word) %>% 
  summarize( n= n(), 
             rating= mean(rating) ) %>%
  ggplot(aes(n, rating)) + 
  geom_hline(yintercept= mean(chocolate$rating)) + 
  geom_jitter(color= "blue", alpha= 0.5) + 
  geom_text(aes(label= word),
            check_overlap= TRUE, 
            vjust= "top", 
            hjust= "left") +
  scale_x_log10() 
```

@fig-mem-char is taken from https://juliasilge.com/blog/chocolate-ratings/. From this visualization, we can see that the phrases and most memorable charactersists that were often associated with a higher rating were "balanced" and "complex", as well as fruity chocolate like "fruit", "Cardamon", "floral".

### Country Bean of Origin

```{r}
#| label: fig-cob-vis
#| fig-cap: "Country of Bean Origin"

chocolate_modified <- chocolate %>%
  mutate(name_long = country_of_bean_origin) %>%
  group_by(name_long) %>%
  count(name_long)

chocworld_data <- world %>%
  full_join(y = chocolate_modified,
  by = "name_long") %>%
  mutate(numBars = ifelse(is.na(n), 0, n))

ggplot(data = chocworld_data) +
  scale_fill_gradient(low = "#F0FEFB", high = "#044F3F") +
  geom_sf(aes(fill = numBars, geometry = geometry)) +
  labs(title = "Map of countries where cacao beans were produced")
```

@fig-cob-vis shows that the majority of cacao beans are produced in central America, South America, Asia, and Africa.

### Company Location

```{r}
#| label: fig-comp-loc
#| fig-cap: "Chocolate Company Location"

chocolate_modified2 <- chocolate %>%
  mutate(name_long = case_when(
    company_location == "U.S.A." ~ "United States",
    company_location == "U.K." ~ "United Kingdom",
    company_location == company_location ~ company_location)) %>%
  group_by(name_long) %>%
  count(name_long)
         
chocworld_data1 <- world %>%
  full_join(y = chocolate_modified2,
  by = "name_long") %>%
  mutate(numBars = ifelse(is.na(n), 0, n))

ggplot(data = chocworld_data1) +
  scale_fill_gradient(low = "#ffffff", high = "#044F3F") +
  geom_sf(aes(fill = numBars, geometry = geometry)) +
  labs(title = "Map of countries where companies are located")

company_loc_count <- chocolate %>%
    count(company_location, sort = TRUE)
```

@fig-comp-loc shows that the majority of countries that chocolate companies are located in are concentrated in North America and Europe, and that the US is host to the largest amount of chocolate companies.

\pagebreak

```{r}
chocolate <- chocolate %>%
  mutate(
    isCocoa = ifelse(str_detect(most_memorable_characteristics, "cocoa"), 1, 0),
    isCreamy = ifelse(str_detect(most_memorable_characteristics, "creamy"), 1, 0),
    isComplex = ifelse(str_detect(most_memorable_characteristics, "complex"), 1, 0),
    isBitter = ifelse(str_detect(most_memorable_characteristics, "bitter"), 1, 0),
    isOff = ifelse(str_detect(most_memorable_characteristics, "off"), 1, 0),
    isChemical = ifelse(str_detect(most_memorable_characteristics, "chemical"), 1, 0),
    isFruit = ifelse(str_detect(most_memorable_characteristics, "fruit"), 1, 0),
  )
```

```{r}
#| label: most-memorable-cleaning

chocolate_clean <- chocolate %>%
  separate(most_memorable_characteristics, sep= ",", into= c("most_memorable", "other_memorable"), extra= "merge") %>%
  select(-other_memorable) 
```

```{r}
#|label: cleaning-dataset
chocolate_clean <- chocolate_clean %>%
  mutate(
    top_memorable= case_when(
      str_detect(most_memorable, "cream") ~ "fatty_smooth", 
      str_detect(most_memorable, "fatty") ~ "fatty_smooth", 
      str_detect(most_memorable, "smooth") ~ "fatty_smooth", 
      str_detect(most_memorable, "dairy") ~ "fatty_smooth", 
      str_detect(most_memorable, "roast") ~ "roast", 
      str_detect(most_memorable, "earth") ~ "roast", 
      str_detect(most_memorable, "smoke") ~ "roast", 
      str_detect(most_memorable, "wood") ~ "roast", 
      str_detect(most_memorable, "bitter") ~ "roast", 
      str_detect(most_memorable, "intense") ~ "strong_sweet", 
      str_detect(most_memorable, "sweet") ~ "strong_sweet", 
      str_detect(most_memorable, "cocoa") ~ "strong_sweet", 
      str_detect(most_memorable, "caramel") ~ "strong_sweet", 
      str_detect(most_memorable, "brownie")~ "strong_sweet", 
      str_detect(most_memorable, "sandy") ~ "rough_texture", 
      str_detect(most_memorable, "dry") ~ "rough_texture", 
      str_detect(most_memorable, "gritty") ~ "rough_texture", 
      str_detect(most_memorable, "coarse") ~ "rough_texture", 
      str_detect(most_memorable, "chalky") ~ "rough_texture", 
      str_detect(most_memorable, "powdery") ~ "rough_texture", 
      str_detect(most_memorable, "nut") ~ "nutty", 
      str_detect(most_memorable, "sticky") ~ "greasy", 
      str_detect(most_memorable, "oily") ~ "greasy", 
      str_detect(most_memorable, "spic") ~ "spiced", 
      str_detect(most_memorable, "molasses") ~ "spiced", 
      str_detect(most_memorable, "floral") ~ "floral", 
      str_detect(most_memorable, "grassy") ~ "floral", 
      str_detect(most_memorable, "vanilla") ~ "floral", 
      str_detect(most_memorable, "fruit") ~ "fruity", 
      str_detect(most_memorable, "tart") ~ "fruity", 
      str_detect(most_memorable, "banana") ~ "fruity", 
      str_detect(most_memorable, "berry") ~ "fruity", 
      str_detect(most_memorable, "berries") ~ "fruity", 
      str_detect(most_memorable, "citrus") ~ "fruity", 
      str_detect(most_memorable, "lemon") ~ "fruity", 
      str_detect(most_memorable, "complex") ~ "complex", 
      TRUE ~ "other"
    )
  )

```

```{r}
#| label: clean_bean_origin
chocolate_clean$continent_bean <- countrycode(sourcevar= chocolate_clean[["country_of_bean_origin"]],origin= "country.name", 
                                              destination= "continent")

```

```{r}
#| label: bean_origin_clean_more
chocolate_clean <- chocolate_clean %>%
  mutate(continent_bean= ifelse(
    country_of_bean_origin== "U.S.A.", "North America", continent_bean
  )) 

chocolate_clean <- chocolate_clean %>%
  mutate(continent_bean= ifelse(
    continent_bean== "Americas", "South America", continent_bean
  ))
```

```{r}
#| label: finalizing_bean_clean

chocolate_clean <- chocolate_clean %>%
  mutate(continent_bean= case_when(
    continent_bean== "South America" ~ "South America", 
    continent_bean== "Africa" ~ "Africa", 
    continent_bean== "Asia" ~ "Asia", 
    TRUE ~ "Other"
  ))

```

```{r}
#| label: clean_company

chocolate_clean$continent_company <- countrycode(sourcevar= chocolate_clean[["company_location"]],origin= "country.name", 
                                              destination= "continent")

```

```{r}
#| label: clean_company_continual

chocolate_clean <- chocolate_clean %>%
  mutate(continent_company= ifelse(
    company_location== "U.S.A.", "North America", continent_company
  )) %>%
  mutate(continent_company=ifelse(
    company_location== "Canada", "North America", continent_company
  )) %>%
  mutate(continent_company= ifelse(
    continent_company== "Americas", "South America", continent_company
    )
  )
```

```{r}
#| label: final_clean
chocolate_clean <- chocolate_clean %>%
  mutate(continent_company= case_when(
    continent_company== "North America" ~ "North America", 
    continent_company== "Europe" ~ "Europe", 
    TRUE ~ "Other"
  ))

```

### Data Cleaning

To get our data ready for modeling, we first performed some data cleaning.

1.  One of the variables that we are using in our modeling is a list of most memorable characteristics by the rater. To organize this variable in a way that can be used for our model, we assumed that the first characteristic listed was the dominant characteristic and made the biggest lasting impression. So, we only kept the first characteristic. From there, because there are a variety of characteristics, we decided to group them into some general groups: fatty_smooth, roast, strong_sweet, rough_texture, nutty, greasy, spiced, floral, fruity, complex, and other. For example, we put "cream" and "dairy" in the category of "fatty_smooth". Another example is that characteristics that contained the word "fruit" or "berry" were grouped together into "fruity".

2.  Next, we also decided to simplify the locations of cocoa bean production. From our EDA, we learned that cocoa bean production locations are mostly based in South America, Asia, and Africa. So, we categorized the countries of cocoa bean production by the most popular continent categories: South America, Africa, Asia, and Other. 

3.  Similarly, from our EDA, we learned that the company locations are mostly based in North America and Europe. So, we categorized the countries of cocoa bean production by the most popular continent categories: North America, Europe, and Other. 

4.  We created a new variable that was the number of ingredients. 

5.  In addition to the number of ingredients, we created 2 new variables: vanilla and salt. These variables indicated whether their specified ingredient was listed in the ingredients list. From our EDA, we learned that the presence of salt and vanilla seems to affect the rating the most out of all the ingredients.

### Modeling

Our main goal of this analysis is to understand how the characteristics of a chocolate can explain its rating. Although the rating only goes from 1 to 5 in 0.25 increments, we treated rating as a quantitative continuous variable. Therefore, we used a linear regression model to fit and predict the rating from the features of a chocolate. We decided compare 2 models: a full model that had all the explanatory variables that we were interested in (location of cocoa bean production, location of chocolate company, number of ingredients, presence of vanilla, presence of salt, top memorable characteristics, and cocoa percentage) and a model with just the "taste" predictors (number of ingredients, presence of vanilla, presence of salt, top memorable characteristics, and cocoa percentage). We defined Model 1 as our model with just the "taste" predictors and Model 2 as our full model. 

To evaluate which model performed better, we decided to perform a cross-validation and compare R-squared and RMSE values instead.

# Results

### Ratings vs cocoa percent, ingredients, most memorable characteristics

```{r}
#| label: inital-split

set.seed(2100)
choco_split <- initial_split(chocolate_clean)
choco_training <- training(choco_split)
choco_testing <- testing(choco_split)

choco_spec <- linear_reg() %>%
  set_engine("lm")

choco_rec1 <- recipe(rating ~ cocoa_percent + vanilla + salt + num_ingres + top_memorable, data = choco_training) %>%
  step_center(num_ingres, cocoa_percent) %>%
  step_dummy(all_nominal_predictors()) %>%
  step_zv(all_predictors())

choco_wflow1 <- workflow() %>%
  add_model(choco_spec) %>%
  add_recipe(choco_rec1)

set.seed(2500)
choco_folds <- vfold_cv(choco_training, v = 5)
choco_fit_rs1 <- choco_wflow1 %>%
  fit_resamples(choco_folds)

cv_metrics1 <- collect_metrics(choco_fit_rs1, summarize = FALSE)

cv_metrics1 %>%
  mutate(.estimate = round(.estimate, 3)) %>%
  pivot_wider(id_cols = id, names_from = .metric, values_from = .estimate) %>%
  kable(col.names = c("Fold", "RMSE", "R-squared"), caption = "Model 1")

#choco_fit <- linear_reg() %>%
  #set_engine("lm") %>%
  #fit(rating ~ cocoa_percent + vanilla + salt +
        #num_ingres + top_memorable, data = chocolate_clean)

#tidy(choco_fit)

#glance(choco_fit) %>%
  #select(adj.r.squared, AIC, BIC)
```

### All predictors

```{r}
#| label: fitting full model

choco_rec2 <- recipe(rating ~ cocoa_percent + vanilla + salt + num_ingres + 
                       top_memorable + continent_company + continent_bean, 
                     data = choco_training) %>%
  step_center(num_ingres, cocoa_percent) %>%
  step_dummy(all_nominal_predictors()) %>%
  step_zv(all_predictors())

choco_wflow2 <- workflow() %>%
  add_model(choco_spec) %>%
  add_recipe(choco_rec2)

set.seed(2500)
choco_folds <- vfold_cv(choco_training, v = 5)
choco_fit_rs2 <- choco_wflow2 %>%
  fit_resamples(choco_folds)

cv_metrics2 <- collect_metrics(choco_fit_rs2, summarize = FALSE)

cv_metrics2 %>%
  mutate(.estimate = round(.estimate, 3)) %>%
  pivot_wider(id_cols = id, names_from = .metric, values_from = .estimate) %>%
  kable(col.names = c("Fold", "RMSE", "R-squared"), caption = "Model 2")


#choco_fit_full <- linear_reg() %>%
  #set_engine("lm") %>%
  #fit(rating ~ cocoa_percent + vanilla + salt +
        #num_ingres + top_memorable + continent_company, 
      #data = chocolate_clean)

#tidy(choco_fit_full)

#glance(choco_fit_full) %>%
  #select(adj.r.squared, AIC, BIC)
```

```{r}
#| label: fig-model-comp1
#| fig-cap: "Comparing Model 1 and Model 2"

#RMSE Visualization
ggplot() +
  geom_point(data = cv_metrics1 %>% filter(.metric == "rmse"),
    mapping = aes(x = id, y = .estimate),
    color = "#1E88E5") +
  geom_line(data = cv_metrics1 %>% filter(.metric == "rmse"),
    mapping = aes(x = id,y = .estimate,
    color = "Model 1", group = 1)) +
  geom_point(data = cv_metrics2 %>% filter(.metric == "rmse"),
    mapping = aes(x = id,y = .estimate),
    color = "#FFC107") +
  geom_line(data = cv_metrics2 %>% filter(.metric == "rmse"),
    mapping = aes(x = id,y = .estimate,
    color = "Model 2 (Full model)", group = 1)) +
  scale_color_manual(name = "Regression Model",
    breaks=c("Model 1", "Model 2 (Full model)"),
    values=c("Model 1" = "#1E88E5",
    "Model 2 (Full model)" = "#FFC107")) +
  labs(
    title = "Visualization of RMSE for each Cross Validation Fold",
    subtitle = "Separated by Model",
    y = "RMSE Value",
    x = "Fold"
  )


#RSQ Visualization

ggplot() +
  geom_point(data = cv_metrics1 %>% filter(.metric == "rsq"),
    mapping = aes(x = id, y = .estimate),
    color = "#1E88E5") +
  geom_line(data = cv_metrics1 %>% filter(.metric == "rsq"),
    mapping = aes(x = id,y = .estimate,
    color = "Model 1", group = 1)) +
  geom_point(data = cv_metrics2 %>% filter(.metric == "rsq"),
    mapping = aes(x = id,y = .estimate),
    color = "#FFC107") +
  geom_line(data = cv_metrics2 %>% filter(.metric == "rsq"),
    mapping = aes(x = id,y = .estimate,
    color = "Model 2 (Full model)", group = 1)) +
    scale_color_manual(name = "Regression Model",
    breaks=c("Model 1", "Model 2 (Full model)"),
    values=c("Model 1" = "#1E88E5",
    "Model 2 (Full model)" = "#FFC107")) +
  labs(
    title = "Visualization of R-squared for each Cross Validation Metric",
    subtitle = "Separated by Model",
    y = "Rsq Value",
    x = "Fold"
  )

```

As both models have similar RMSE and R-squared values for each fold in cross-validation (as seen in Table 1 and 2 and in @fig-model-comp1 ), we will choose the first model as it has fewer predictor variables and aligns with the goals of parsimony, as it is a less complicated model yet doesn't sacrifice predictive capability.

```{r}
#| label: print-out-model

choco_fit <- linear_reg() %>%
  set_engine("lm") %>%
  fit(rating ~ cocoa_percent + vanilla + salt +
        num_ingres + top_memorable, data =
        chocolate_clean)

tidy(choco_fit) %>%
  kable(digits=3, caption= "Model 1 Fit")
```

Because our R-squared values are so low, we wanted to explore other options. From https://juliasilge.com/blog/chocolate-ratings/, Dr. Silge made a model predicting a model to predict ratings from most-memorable characteristics. Using her model as a footprint, we decided to add to the most memorable characteristic and make a new model. Her model found which words were more associated with higher or lower ratings. We decided to take her words and create variables out of them. For example, we have a categorical variable detecting whether or not "cocoa" appears in most-memorable characteristics. We ended looking for the following words: cocoa, off, chemical, fruit, creamy, complex and bitter.

So, we created a 3rd model with the variables: number of ingredients, presence of vanilla, presence of salt, top memorable characteristic, cocoa percentage, presence of "cocoa" in most memorable characteristics, presence of "off" in most memorable characteristics, and so on with the other words/characteristics mentioned above.

```{r}
#| label: new-model-fit

set.seed(1200)

choco_spec <- linear_reg() %>%
  set_engine("lm")

choco_rec3 <- recipe(rating ~ cocoa_percent + vanilla + salt + num_ingres + top_memorable +
                       isCocoa + isOff + isChemical + isFruit + 
                       isCreamy + isComplex + isBitter, data = choco_training) %>%
  step_center(num_ingres, cocoa_percent) %>%
  step_dummy(all_nominal_predictors()) %>%
  step_zv(all_predictors())

choco_wflow3 <- workflow() %>%
  add_model(choco_spec) %>%
  add_recipe(choco_rec3)

set.seed(2900)
choco_folds <- vfold_cv(choco_training, v = 5)
choco_fit_rs3 <- choco_wflow3 %>%
  fit_resamples(choco_folds)

cv_metrics3 <- collect_metrics(choco_fit_rs3, summarize = FALSE)

cv_metrics3 %>%
  mutate(.estimate = round(.estimate, 3)) %>%
  pivot_wider(id_cols = id, names_from = .metric, values_from = .estimate) %>%
  kable(col.names = c("Fold", "RMSE", "R-squared"), caption = "Model 3")
```

```{r}
#| label: fig-model-comp2
#| fig-cap: "Comparing Model 1 and 3"


ggplot() +
  geom_point(data = cv_metrics1 %>% filter(.metric == "rmse"),
    mapping = aes(x = id, y = .estimate),
    color = "#1E88E5") +
  geom_line(data = cv_metrics1 %>% filter(.metric == "rmse"),
    mapping = aes(x = id,y = .estimate,
    color = "Model 3", group = 1)) +
  geom_point(data = cv_metrics3 %>% filter(.metric == "rmse"),
    mapping = aes(x = id,y = .estimate),
    color = "#FFC107") +
  geom_line(data = cv_metrics3 %>% filter(.metric == "rmse"),
    mapping = aes(x = id,y = .estimate,
    color = "Model 3 (New model)", group = 1)) +
  scale_color_manual(name = "Regression Model",
    breaks=c("Model 1", "Model 3 (New model)"),
    values=c("Model 1" = "#1E88E5",
    "Model 3 (New model)" = "#FFC107")) +
  labs(
    title = "Visualization of RMSE for each Cross Validation Fold",
    subtitle = "Separated by Model",
    y = "RMSE Value",
    x = "Fold"
  )


#RSQ Visualization

ggplot() +
  geom_point(data = cv_metrics1 %>% filter(.metric == "rsq"),
    mapping = aes(x = id, y = .estimate),
    color = "#1E88E5") +
  geom_line(data = cv_metrics1 %>% filter(.metric == "rsq"),
    mapping = aes(x = id,y = .estimate,
    color = "Model 1", group = 1)) +
  geom_point(data = cv_metrics3 %>% filter(.metric == "rsq"),
    mapping = aes(x = id,y = .estimate),
    color = "#FFC107") +
  geom_line(data = cv_metrics3 %>% filter(.metric == "rsq"),
    mapping = aes(x = id,y = .estimate,
    color = "Model 3 (New model)", group = 1)) +
    scale_color_manual(name = "Regression Model",
    breaks=c("Model 1", "Model 3 (New model)"),
    values=c("Model 1" = "#1E88E5",
    "Model 3 (New model)" = "#FFC107")) +
  labs(
    title = "Visualization of R-squared for each Cross Validation Metric",
    subtitle = "Separated by Model",
    y = "Rsq Value",
    x = "Fold"
  )
```

From Table 4 and @fig-model-comp2, we can see that the model has improved.

# Discussion

```{r}
#| label: output final model

choco_test_fit <- choco_wflow3 %>%
  fit(data = choco_testing)

tidy(choco_test_fit, conf.int = TRUE) %>%
  kable(digits = 3)

```

$$
\begin{aligned}
\hat{rating} = & 3.277  - .006 \times CocoaPercent + .027 \times NumIngredients \\ & + 0.128 \times isCocoa + 0.212\times isOff - .811 \times isChemical \\ & + .060 \times is Fruit +.339 \times isCreamy + .359 \times isComplex \\ &-.560 \times isBitter - .291 \times Vanilla_x1 - .165 \times Salt_X1 \\ &-.019 \times topMemFattySmooth  -.023 \times topMemFloral \\ &+ .176 \times topMemFruity + .148 \times topMemGreasy + .051 \times topMemNutty \\ & - .122 \times topMemOther  - .137 \times topMemRoast - .201 \times topMemRough \\ &- .044 \times topMemSpiced - .012 \times topMemStrongSweet
\end{aligned}
$$

Interpretation of a few coefficients:

Question: How do you interpret memorable characteristics in an intercept?

Cocoa Percent: For every additional percentage in cocoa percent, the predicted rating is expected to decrease by .006 points, on average, with all else held constant.

TopMemorableFloral: If a chocolate bar is noted as having the memorable characteristic of Floral Notes, the predicted rating is expected to decrease by -.023 rating points compared to chocolate bars that don't have this memorable characteristic, on average, with all else held constant.

Although we did improve our model in the 3rd model and answered our hypotheses, there are additional items for the future. One of the most obvious ones is trying ordinal logistic regression. For our project, we chose to use linear regression in large part due to the fact that we have not covered ordinal logistic regression. Because our response variable (rating) is not truly continuous, this has influenced the shape of our residuals (as seen in @fig-resid ), making it hard to verify if conditions have been met for linear regression. While ordinal logistic regression would not guarantee a better model, our response variable could perhaps fit the conditions of the ordinal logistic regression better. In addition to trying a different type of model, getting more expansive data (taster's chocolate preferences, quality of chocolate, etc. ) could also potentially improve the model.

```{r}
#| label: fig-resid
#| fig-cap: "Residuals and Ratings"

choco_aug <- augment(choco_fit$fit)

ggplot(data= choco_aug, aes(x= .fitted, y= .resid, color= rating)) + 
  geom_point() + 
  geom_line(y=0, color= "blue") + 
  scale_colour_gradient2(low= "red", 
                         high= "blue")
```
